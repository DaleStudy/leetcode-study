# ì—°ê´€ ë§í¬
- [ë¬¸ì œ í’€ì´ ìŠ¤ì¼€ì¤„](https://github.com/orgs/DaleStudy/projects/6/views/5)
- [ë‹µì•ˆ ì½”ë“œ ì œì¶œë²•](https://github.com/DaleStudy/leetcode-study/wiki/%EB%8B%B5%EC%95%88-%EC%A0%9C%EC%B6%9C-%EA%B0%80%EC%9D%B4%EB%93%9C)

# Problem
- ë¬¸ì œ ë§í¬ : https://leetcode.com/problems/validate-binary-search-tree/
- ë¬¸ì œ ì´ë¦„ : validate-binary-search-tree
- ë¬¸ì œ ë²ˆí˜¸ : 251
- ë‚œì´ë„ : medium
- ì¹´í…Œê³ ë¦¬ : binary search tree

# ë¬¸ì œ ì„¤ëª…

Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.

#### Constraints:

- The number of nodes in the tree is in the range [1, 104].
- 2^31 <= Node.val <= 2^31 - 1

# ì•„ì´ë””ì–´
- ê° ë…¸ë“œ ë³„ 



# ì½”ë“œ (Solution)
```cpp

class Solution {
public:
    bool isValidBSTHelper(TreeNode* root, long min, long max){
        if (!root) {
            return true;
        }

        if (root->val <= min || root->val >= max) {
            return false;
        }

        return isValidBSTHelper(root->left, min, root->val) &&
               isValidBSTHelper(root->right, root->val, max);
    }

    bool isValidBST(TreeNode* root) {
        return isValidBSTHelper(root, LONG_MIN, LONG_MAX);
    }
};
```

## ì½”ë“œ ì„¤ëª…

- INT_MIN / INT_MAXê°€ Constraintì˜ ê²½ê³„ê°’ì´ì§€ë§Œ, í•´ë‹¹ ê°’ì„ ì´ìš©í•  ê²½ìš° ê²½ê³„ê°’ ë¹„êµ ì‹œ ë²ˆê±°ë¡œì›Œì§€ë¯€ë¡œ LONGìœ¼ë¡œ ë¹„êµí•˜ë„ë¡ ì²˜ë¦¬


# ìµœì í™” í¬ì¸íŠ¸ (Optimality Discussion)
- íŠ¹ì´ ì‚¬í•­ ì—†ìŒ

# ğŸ§ª í…ŒìŠ¤íŠ¸ & ì—£ì§€ ì¼€ì´ìŠ¤

## INT_MAX / INT_MINìœ¼ë¡œ í•  ê²½ìš°
- root = [2147483647] ì¸ ê²½ìš° ì—£ì§€ ì¼€ì´ìŠ¤

# ğŸ“š ê´€ë ¨ ì§€ì‹ ë³µìŠµ

# ğŸ” íšŒê³ 


