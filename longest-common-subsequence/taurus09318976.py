'''
문제 핵심 : 이 문제는 두 문자열에서 가장 긴 공통 부분수열의 길이를 찾는 것임
여기서 부분수열이란, 원래 문자열에서 일부 문자를 삭제해도 되지만, 남은 문자들의 순서는 바뀌면 안되는 새로운 문자열임

해결방법 : 1) 2차원 표를 만들어서 각 위치에 "여기까지의 최대 공통 부분수열 길이"를 저장함
        2) 두 문자가 같으면, 이전 결과에 1을 더함
        3) 두 문자가 다르면, 위쪽 또는 왼쪽 중 더 큰 값을 가져옴 

시간 복잡도: O(m × n)
    외부 반복문이 m번 실행됩니다 (text1의 길이)
    내부 반복문이 n번 실행됩니다 (text2의 길이)
    각 반복에서 하는 작업은 상수 시간 O(1)입니다
    따라서 총 시간 복잡도는 O(m × n)입니다

공간 복잡도: O(m × n)
    (m+1) × (n+1) 크기의 2차원 배열 dp를 사용합니다
    따라서 공간 복잡도는 O(m × n)입니다

'''

class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str):
        m = len(text1)  # 첫 번째 문자열의 길이를 m에 저장
        n = len(text2)  # 두 번째 문자열의 길이를 n에 저장
        
        # (m+1) x (n+1) 크기의 2차원 리스트를 만들고 모든 값을 0으로 초기화
        # +1을 하는 이유: 빈 문자열과의 비교를 위해 첫 번째 행과 열을 0으로 둠
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # 1부터 시작하는 이유: 0번째 행과 열은 빈 문자열을 의미하므로 이미 0으로 초기화됨
        for i in range(1, m + 1):  # text1의 각 문자에 대해
            for j in range(1, n + 1):  # text2의 각 문자에 대해
                # text1의 (i-1)번째 문자와 text2의 (j-1)번째 문자가 같은지 확인
                # i-1, j-1을 사용하는 이유: dp 배열은 1부터 시작하지만 문자열 인덱스는 0부터 시작
                if text1[i-1] == text2[j-1]:
                    # 같으면: 대각선 위 값에 1을 더함 (이전까지의 LCS + 현재 일치하는 문자 1개)
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    # 다르면: 위쪽 값과 왼쪽 값 중 더 큰 값을 선택
                    # 위쪽: text1에서 현재 문자를 제외한 경우
                    # 왼쪽: text2에서 현재 문자를 제외한 경우
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        # dp[m][n]에는 전체 문자열에 대한 LCS 길이가 저장됨
        return dp[m][n]




