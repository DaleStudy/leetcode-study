class Solution:
    def numDecodings(self, s: str) -> int:
      # 예외 처리: "0"으로 시작하면 불가능
      if not s or s[0] == '0':
          return 0

      n = len(s)
      dp = [0] * (n + 1)

      # 초기값
      dp[0] = 1  # 빈 문자열
      dp[1] = 1  # 첫 번째 문자 (이미 "0" 체크함)

      for i in range(2, n + 1):
          # 한 자리 숫자 (1~9)
          if s[i-1] != '0':
              dp[i] += dp[i-1]

          # 두 자리 숫자 (10~26)
          two_digit = int(s[i-2:i])
          if 10 <= two_digit <= 26:
              dp[i] += dp[i-2]

      return dp[n]


"""
================================================================================
풀이 과정
================================================================================
- "226" → 2|2|6 (BBF), 22|6 (VF), 2|26 (BZ) → 3가지 방법 존재
- DP를 이용해서 각 위치에서 가능한 디코딩 경우의 수를 계산
- 한 자리(1~9)와 두 자리(10~26) 숫자를 고려하여 누적

[1차 시도]
────────────────────────────────────────────────────────────────────────────────
1. 접근 방법
   - DP 배열 사용: dp[i] = 문자열의 처음부터 i번째까지의 디코딩 경우의 수
   - 각 위치에서 한 자리 숫자(1~9)로 디코딩 가능하면 dp[i-1] 더하기
   - 두 자리 숫자(10~26)로 디코딩 가능하면 dp[i-2] 더하기

2. 구현
        n = len(s)
        dp = [0] * (n + 1)

        # 초기값 설정
        dp[0] = 1  # 빈 문자열
        dp[1] = 1  # 첫 번째 문자 (0이 아니면 1가지)

        for i in range(2, n + 1):
            # 한 자리 숫자 (1~9)
            if s[i-1] != '0':
                dp[i] += dp[i-1]

            # 두 자리 숫자 (10~26)
            two_digit = int(s[i-2:i])
            if 10 <= two_digit <= 26:
                dp[i] += dp[i-2]

3. 예외 처리
   - "0"으로 시작하는 문자열은 디코딩 불가능 → 0 반환
   - 빈 문자열 체크

4. 시간 복잡도: O(n) - 문자열을 한 번만 순회
5. 공간 복잡도: O(n) - DP 배열 사용
"""
