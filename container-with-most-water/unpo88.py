class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height) - 1
        max_area = 0

        while left < right:
            min_height = min(height[left], height[right])
            width = right - left
            area = min_height * width

            max_area = max(max_area, area)

            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        
        return max_area


"""
================================================================================
풀이 과정
================================================================================

[1차 시도] Brute Force로 접근하면?
────────────────────────────────────────────────────────────────────────────────
1. 모든 (i, j) 쌍에 대해 넓이 계산
2. height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
   - (0, 1): min(1, 8) × 1 = 1
   - (0, 2): min(1, 6) × 2 = 2
   - (0, 8): min(1, 7) × 8 = 8
   - (1, 8): min(8, 7) × 7 = 49  ← 최대
   ... 모든 쌍을 확인해야 함

3. 시간복잡도: O(n²) - 시간 초과!
4. 더 효율적인 방법이 필요함 → Two Pointer로 접근

────────────────────────────────────────────────────────────────────────────────
[2차 시도] Two Pointer (양끝에서 좁히기)
────────────────────────────────────────────────────────────────────────────────
5. 핵심 아이디어:
   - 넓이 = min(height[left], height[right]) × (right - left)
   - 폭(width)은 양끝에서 시작할 때 최대
   - 포인터를 안쪽으로 이동하면 폭은 무조건 줄어듦
   - 따라서 높이가 커져야 넓이가 커질 가능성이 있음

6. 왜 작은 쪽을 이동하는가?
   - 작은 쪽이 높이의 병목 (min이 작은 쪽에 의해 결정됨)
   - 큰 쪽을 이동하면? → 높이는 그대로거나 작아짐, 폭은 줄어듦 → 손해만
   - 작은 쪽을 이동하면? → 높이가 커질 가능성 있음 → 이득 가능성

7. 동작 예시: height = [1, 8, 6, 2, 5, 4, 8, 3, 7]

   Step 1: L=0, R=8
           min(1, 7) × 8 = 8
           height[L]=1 < height[R]=7 → L 이동

   Step 2: L=1, R=8
           min(8, 7) × 7 = 49  ← 최대!
           height[L]=8 > height[R]=7 → R 이동

   Step 3: L=1, R=7
           min(8, 3) × 6 = 18
           height[L]=8 > height[R]=3 → R 이동

   ... L과 R이 만날 때까지 반복

8. 시간복잡도: O(n) - 한 번만 순회
9. 공간복잡도: O(1) - 추가 공간 없음
"""
