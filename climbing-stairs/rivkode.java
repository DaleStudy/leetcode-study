/*
이것도 dp 아닌가 ?
이전의 계산들을 다음 계산에 사용할 수 있음
메모이제이션과 dp를 사용하면 풀 수 있을 것 같은데
dp 아니네

점화식

count(n) = count(n-1) + 

만약 5를 만드려면
3을 만드는 경우의 수와 2를 만드는 경우의 수를 곱하면 되는것 아닌가 ?

3을 만드려면 ?
2를 만들 수 있는 경우의 수에 1을 만들 수 있는 경우의 수를 더해주면 되는거 아닌가 ?
순서를 바꾸고 ?

111
21
12

1111
211
121
112
22

11111
2111
1211
1121
1112
221
212
122

111111
21111
12111
11211
11121
11112
1122
1212
1221
2211
2121
2112
222




1 - 1
2 - 2
3 - 3
4 - 5
5 - 8
6 - 13

count(3) = coun(1) + count(2)
count(4) = count(3) + count(2)

count(n) = count(n-1) + count(n-2)

*/

class Solution {
    public int climbStairs(int n) {
        // n은 45까지 있으므로 배열을 45까지 구하면 됨

        int[] arr = new int[45];
        arr[0] = 1;
        arr[1] = 2;

        for (int i=2; i<45; i++) {
            arr[i] = arr[i-1] + arr[i-2];
        }

        return arr[n-1];
    }
}

