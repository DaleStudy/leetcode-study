class Solution {
    // 정상까지 n걸음이 소모된다고 할 때, n을 구할 수 있는 중복되지 않는 경우의 수를 계산하는 문제
    // 계단은 1걸음이나 2걸음씩 올라갈 수 있다.
    fun climbStairs(n: Int): Int {
        // 계단이 1개라면 무조건 1을 반환
        if(n == 1) return 1
        // 숫자로 된 배열을 선언(편의상 1번째 계단부터 시작하도록 n+1로 선언)
        val dp = IntArray(n + 1)
        // 첫번째 계단을 올라가는 방법은 1가지
        dp[1] = 1
        // 두번째 계단까지 올라가는 방법은 2가지(1+1, 2)
        dp[2] = 2

        //이제 3번째 계단부터 n번째 계단인 정상까지 올라가는 방법을 계산
        for(i in 3..n){
            dp[i] = dp[i - 1] + dp[i - 2]
        }
        return dp[n]
    }
}

