class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n

        prev2, prev1 = 1, 2

        for i in range(3, n + 1):
            current = prev1 + prev2
            prev2 = prev1
            prev1 = current

        return prev1

"""
================================================================================
풀이 과정 - 08:49 시작 ~ 08:54 종료 (5분 소요)
================================================================================

1. 계단 올라갈건데, n step씩 올라감
2. 1 또는 2단계씩 갈 수 있는데, 얼마나 많이 탑까지 올라갈 수 있는 방법이 있을까?
3. 재귀로 내가 1 또는 2로 갈 수 있는 방법을 모두 구해야할 것 같은데?
4. n - 1, n - 2
5. 3번째 계단부터 첫 번째 계단 갈 수 있는 방법 + 두 번째 계단 갈 수 있는 방법
6. DP로 풀어야할 것 같은데?
7. 이거 계단 경우의 수 보니까 피보나치 수열이네?


[1차 시도] 딕셔너리를 사용한 DP
────────────────────────────────────────────────────────────────────────────────
7. 피보나치 수열과 유사한 패턴 발견
8. dp[i] = dp[i-1] + dp[i-2] 점화식 도출
9. 기저 사례: dp[1] = 1, dp[2] = 2

        dp = { 1: 1, 2: 2}
        for i in range(3, n + 1):
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]

10. 정상적으로 통과되는 것 확인 완료


[2차 개선] 공간 복잡도 최적화
────────────────────────────────────────────────────────────────────────────────
11. 잘 생각해보면 공간 복잡도를 아예 딕셔너리를 안만들고 푸는 방법도 있을듯?
13. 변수 2개(prev2, prev1)로 공간 복잡도를 O(1)로 개선

        if n <= 2:
            return n

        prev2, prev1 = 1, 2

        for i in range(3, n + 1):
            current = prev1 + prev2
            prev2 = prev1
            prev1 = current

        return prev1

14. 공간 복잡도 O(n) → O(1)로 개선 완료
15. 최종 통과 확인 완료
"""
