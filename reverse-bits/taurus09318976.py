'''
문제의 의도:
이 문제는 32비트 부호 없는 정수의 비트를 뒤집는 문제임. 
즉, 이진수 표현에서 첫 번째 비트와 마지막 비트를 바꾸고, 
두 번째 비트와 31번째 비트를 바꾸는 식으로 모든 비트의 순서를 뒤집어야 함.

해결 방법:
if문을 사용해서 마지막 비트가 1인지 확인하고, 1이면 결과에 추가하는 방식.
이 방법은 "동전 줍기"와 같음
원본에서 동전(비트) 하나씩 확인
동전이 있으면(비트가 1이면) 주머니(result)에 넣기
동전이 없으면(비트가 0이면) 그냥 넘어가기
이렇게 하면 자연스럽게 순서가 뒤바뀜

Example 1.의 경우
Input: n = 43261596 (이진수: 00000010100101000001111010011100)

1번째 반복:
- result = 0 << 1 = 0
- n & 1 = 0 (마지막 비트가 0)
- if문 실행 안 됨 (result는 그대로 0)
- n = n >> 1 = 0000001010010100000111101001110

2번째 반복:
- result = 0 << 1 = 0  
- n & 1 = 0 (마지막 비트가 0)
- if문 실행 안 됨 (result는 그대로 0)
- n = n >> 1 = 000000101001010000011110100111

3번째 반복:
- result = 0 << 1 = 0
- n & 1 = 1 (마지막 비트가 1)
- if문 실행: result = 0 + 1 = 1
- n = n >> 1 = 00000010100101000001111010011

4번째 반복:
- result = 1 << 1 = 10 (이진수)
- n & 1 = 1 (마지막 비트가 1)  
- if문 실행: result = 10 + 1 = 11 (이진수)
- n = n >> 1 = 0000001010010100000111101001

... (32번 반복)

최종: result = 00111001011110000010100101000000
Output: 964176192

시간 복잡도: O(1)
항상 정확히 32번의 반복을 수행
입력 크기에 관계없이 상수 시간

공간 복잡도: O(1)
몇 개의 변수만 사용하므로 상수 공간
추가 배열이나 자료구조 사용하지 않음

'''
class Solution:
    def reverseBits(self, n: int) -> int:
        # 뒤집힌 비트들을 저장할 결과 변수를 0으로 초기화
        result = 0
        
        # 32비트를 모두 처리하기 위해 32번 반복
        for i in range(32):
            # 결과를 왼쪽으로 1비트 시프트하여 새로운 비트를 넣을 자리 만들기
            # 예: 101 → 1010 (오른쪽에 0이 하나 추가됨)
            result = result << 1
            
            # n & 1로 n의 가장 오른쪽 비트를 추출
            # 그 비트가 1인지 확인
            if n & 1 == 1:
                # 마지막 비트가 1이었다면 result의 가장 오른쪽에 1을 추가
                # 0이었다면 아무것도 안 함 (자동으로 0이 추가된 상태)
                result = result + 1
            
            # n을 오른쪽으로 1비트 시프트하여 다음 비트를 처리할 준비
            n = n >> 1
        
        return result



