class Solution:
    def containsDuplicate(self, nums: list[int]) -> bool:
        return len(set(nums)) != len(nums)

""" 
================================================================================
풀이 과정
================================================================================

[1차 시도] Counter를 이용한 Hash Table
────────────────────────────────────────────────────────────────────────────────
1. Hashing을 이용해서 숫자 Count를 한 것에서 개수가 2이상인 것을 뽑으면 되겠는데?

        nums_count = Counter(nums)
        for count in nums_count.values():
            if count >= 2:
                return True
        return False

2. 속도가 많이 느리네 더 좋은 방법은 없을까?


[2차 시도] Early Return with Hash Table
────────────────────────────────────────────────────────────────────────────────
3. 해싱을 만들면서 2개 이상이면 즉각 return 하도록 구현해볼까?

        nums_count = defaultdict(int)
        for num in nums:
            nums_count[num] += 1

            if nums_count[num] == 2:
                return True
        return False

4. 그래도 속도가 많이 개선되지는 않았네?


[최종 개선] Set을 이용한 비교
────────────────────────────────────────────────────────────────────────────────
5. 속도를 획기적으로 개선하려면 어떻게 접근해볼 수 있을까?
6. set으로 중복을 제거한다음에 개수를 비교해볼 수 있지 않으려나?

        return len(set(nums)) != len(nums)

7. 조금 더 속도가 빨라졌다.


[성능 분석]
────────────────────────────────────────────────────────────────────────────────
8. 근데 잘 생각해보면 Big-O 시간 복잡도는 O(n) 일 것 같은데
9. 그러면 Early Return을 해주는 방법 2가 더 빠르다고 생각했는데 왜 3번 방식이 더 빠를까?
10. set이 CPython 내부에서 C 코드로 실행되는구나 OK
"""
