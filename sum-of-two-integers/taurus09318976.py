'''
문제의 의도 :
이 문제는 + 와 - 연산자를 사용하지 않고 두 정수의 합을 구하는 문제임. 
컴퓨터가 내부적으로 덧셈을 어떻게 처리하는지 이해하는 것이 핵심임.

해결 방법 :
비트 연산을 사용함
XOR (^): 자리수별 덧셈 (올림 없이)
AND (&): + 왼쪽 시프트 (<<): 올림(carry) 계산
올림이 0이 될 때까지 반복

**비트 연산 덧셈 원리
1단계: XOR (^) - "올림 없는 덧셈"
예시: 5 + 3을 이진수로

   101  (5)
 + 011  (3)
 ------

2^0의 자리  1 + 1 = 0 (올림 무시)
2^1의 자리  0 + 1 = 1
2^1의 자리  1 + 1 = 0 (올림 무시)

  101
^ 011
-----
  110  (6) ← 이것이 XOR 결과

2단계: AND (&) + 시프트 (<<) - "올림 계산"
어디서 올림이 발생하는가?
→ 둘 다 1인 자리에서만 올림 발생

  101
& 011
-----
  001  ← 올림이 발생하는 자리

올림을 다음 자리로 이동: << 1 (왼쪽으로 1칸 시프트)

3단계: 다시 1단계와 2단계 반복
이제 6 + 2를 계산:

1단계: 110 ^ 010 = 100 (4)
2단계: (110 & 010) << 1 = 010 << 1 = 100 (4)

다시 4 + 4를 계산:
1단계: 100 ^ 100 = 000 (0)
2단계: (100 & 100) << 1 = 100 << 1 = 1000 (8)

다시 0 + 8을 계산:
1단계: 000 ^ 1000 = 1000 (8)
2단계: (000 & 1000) << 1 = 000 << 1 = 0

-> 올림이 0이 되었으므로 종료. 결과는 8 (1000)

시간 복잡도: O(1)
32비트 정수에서 최대 32번의 반복만 필요
올림이 전파되는 최대 거리가 32비트로 제한됨

공간 복잡도: O(1)
몇 개의 변수만 사용하므로 상수 공간
추가 배열이나 자료구조 사용하지 않음
'''
class Solution:
    def getSum(self, a: int, b: int) -> int:
        # 32비트 정수 범위를 위한 마스크 생성
        # why? Python의 무한 정밀도 정수를 32비트로 제한하기 위해 사용
        mask = 0xFFFFFFFF
        
        # 올림이 0이 될 때까지 반복
        # b가 올림을 나타내므로, 올림이 없으면 덧셈 완료
        while b != 0:
            # XOR 연산으로 올림 없는 덧셈 수행
            sum_without_carry = a ^ b
            
            # AND 연산으로 올림이 발생하는 자리 찾기
            # 왼쪽으로 1비트 시프트하여 올림을 다음 자리로 이동
            carry = (a & b) << 1
            
            # 32비트 범위로 제한하면서 다음 반복을 위해 값 업데이트
            a = sum_without_carry & mask
            b = carry & mask
        
        # 음수 처리: 32비트에서 최대 양수(0x7FFFFFFF)보다 크면 음수로 변환
        if a > 0x7FFFFFFF:
            return ~(a ^ mask)
        else:
            return a



