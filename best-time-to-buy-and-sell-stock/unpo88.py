class Solution:
    def maxProfit(self, prices: list[int]) -> int:
        if not prices:
            return 0

        min_price = prices[0]
        max_profit = 0

        for price in prices[1:]:
            max_profit = max(max_profit, price - min_price)
            min_price = min(min_price, price)

        return max_profit


"""
================================================================================
풀이 과정
================================================================================

[문제 이해]
────────────────────────────────────────────────────────────────────────────────
1. 주어진 배열 prices가 있고 prices[i]는 i날의 특정 주식 가격
2. 하나의 주식을 사기 위해 하루를 선택하고, 그 주식을 팔기 위해 미래의 다른 날을 선택
3. 이 거래에서 얻을 수 있는 최대 이익을 반환
4. 이익을 얻을 수 없다면 0을 반환

    예시 1: [7, 1, 5, 3, 6, 4] → 5
    2일에 사서 5일에 팔면 → 6 - 1 = 5가 나오면서 가장 큰 값

    예시 2: [7, 6, 4, 3, 1] → 0
    아무런 이익이 있는 날이 없음


[1차 시도] Brute Force 접근
────────────────────────────────────────────────────────────────────────────────
5. 모든 (구매일, 판매일) 쌍을 비교해서 최대 이익 찾기
6. 이중 반복문으로 구현

        profit = 0
        for i in range(len(prices)):
            for j in range(i+1, len(prices)):
                profit = max(profit, prices[j] - prices[i])
        return profit

7. 시간복잡도: O(n²) → 시간 초과 발생!


[2차 시도] 최적화 방법 고민
────────────────────────────────────────────────────────────────────────────────
8. 그러면 다른 풀이 방식이 필요할 것 같은데
9. 조건을 정리:
   - 이전 값이 다음 값보다 크면 버려도 된다
   - 이전 값이 다음 값보다 작으면 해당 값을 기록한다
   - 이미 기록된게 있으면 비교해본다

    [7, 1, 5, 9, 3, 6, 4]
    min을 추적하면서 현재가 - min 중 최대값을 찾으면 됨!


[최종 구현] Kadane's Algorithm 변형
────────────────────────────────────────────────────────────────────────────────
10. 한 번의 순회로 최소 구매가와 최대 이익을 동시에 추적
11. 각 시점에서:
    - 현재가 - 최소가 = 지금 팔면 얻는 이익
    - 최대 이익 갱신
    - 최소가 갱신

        min_price = prices[0]
        max_profit = 0

        for price in prices[1:]:
            max_profit = max(max_profit, price - min_price)
            min_price = min(min_price, price)

12. 시간복잡도: O(n) - 한 번의 순회
13. 공간복잡도: O(1) - 상수 공간만 사용
"""
