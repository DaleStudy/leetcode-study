/**
 * 시간복잡도: O(n) - 배열을 한 번만 순회
 * 공간복잡도: O(n) - 길이가 n+1인 DP 배열 사용
 *
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
  // arr[i] = i번째 집부터 마지막 집까지 고려했을 때 훔칠 수 있는 최대 금액
  const arr = new Array(nums.length + 1);

  // 존재하지 않는 집(n+1번째)은 0, 점화식을 위한 계산용 공간임
  arr[nums.length] = 0;

  // 마지막 집만 고려하면 그 집의 금액이 최대값 (이후 집들은 없으니까 0으로 계산한 결과)
  arr[nums.length - 1] = nums[nums.length - 1];

  // 뒤에서부터 계산
  for (let i = nums.length - 2; i >= 0; i--) {
    // i번째 집에서의 결정:
    // 1. i번째 집을 털고 (i+2)번째 집부터 훔치는 경우: nums[i] + arr[i+2]
    // 2. i번째 집을 털지 않고 (i+1)번째 집부터 훔치는 경우: arr[i+1]
    // 두 가지 중 최대값을 선택
    arr[i] = Math.max(nums[i] + arr[i + 2], arr[i + 1]);
  }

  // arr[0]은 0번째 집부터 고려했을 때 훔칠 수 있는 최대 금액
  return arr[0];
};

/* 풀이 설명:
 * 문제의 핵심: 인접한 집은 연속해서 털 수 없을 때 최대로 털 수 있는 금액 찾기
 *
 * 접근 방식: 다이나믹 프로그래밍
 *
 * 1. 상태 정의:
 *    - f(n) = n번째 집부터 마지막 집까지 고려했을 때 털 수 있는 최대 금액
 *
 * 2. 점화식 도출:
 *    - 각 집마다 두 가지 선택이 있음:
 *      1) 현재 집을 털기: 현재 집의 돈 + 두 집 이후부터의 최대 금액
 *      2) 현재 집을 털지 않기: 다음 집부터의 최대 금액
 *    - 따라서 점화식: f(n) = max(nums[n] + f(n+2), f(n+1))
 *
 * 3. 베이스 케이스:
 *    - 존재하지 않는 집: f(n+1) = 0
 *    - 마지막 집: f(n) = nums[n]
 *
 * 4. 계산 방향:
 *    - 뒤에서부터 앞으로 계산 (Bottom-up)
 *    - 마지막 집부터 시작해서 첫 번째 집까지 각 위치에서의 최대 금액 계산
 *
 * 예시 [1,2,3,1]:
 *    - f(4) = 0 (존재하지 않는 집)
 *    - f(3) = 1 (마지막 집)
 *    - f(2) = max(3 + f(4), f(3)) = max(3 + 0, 1) = 3
 *    - f(1) = max(2 + f(3), f(2)) = max(2 + 1, 3) = 3
 *    - f(0) = max(1 + f(2), f(1)) = max(1 + 3, 3) = 4
 *    - 결과: 4 (최적의 선택은 0번째와 2번째 집 털기)
 */
