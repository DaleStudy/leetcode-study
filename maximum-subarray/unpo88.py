class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        current_sum = nums[0]
        max_sum = nums[0]

        for i in range(1, len(nums)):
            # 현재 값부터 새로 시작 vs 이전 합에 추가
            current_sum = max(nums[i], current_sum + nums[i])
            max_sum = max(max_sum, current_sum)

        return max_sum


"""
================================================================================
풀이 과정
================================================================================

1. 부분 배열 중 가장 큰 합을 찾아야 하는데 어떻게 접근하지?
2. Sliding Window? → 음수/양수가 섞여있어서 윈도우 크기를 언제 조절할지 불명확
3. 모든 부분배열을 확인? → O(n²)이라 비효율적
4. 각 위치에서 "현재까지의 최대 부분합"을 추적하면 되지 않을까?


[1차 시도] Dynamic Programming
────────────────────────────────────────────────────────────────────────────────
5. 핵심 아이디어: 각 위치에서 "이 위치를 끝으로 하는" 최대 부분배열의 합 추적
6. current_sum = "현재 위치를 끝으로 하는 최대 부분합"
7. 매 위치에서 선택: 이전 합에 추가 vs 여기서 새로 시작

        current_sum = nums[0]  # 현재 위치까지의 최대 부분합
        max_sum = nums[0]      # 전체 최댓값

        for i in range(1, len(nums)):
            # 이전 합이 양수면 계속, 음수면 버리고 새로 시작
            current_sum = max(nums[i], current_sum + nums[i])
            max_sum = max(max_sum, current_sum)

        return max_sum

8. Example: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]

   i=0: current=-2, max=-2
   i=1: max(1, -2+1=-1) = 1 (새로 시작), max=1
   i=2: max(-3, 1-3=-2) = -2 (이어감), max=1
   i=3: max(4, -2+4=2) = 4 (새로 시작), max=4
   i=4: max(-1, 4-1=3) = 3 (이어감), max=4
   i=5: max(2, 3+2=5) = 5 (이어감), max=5
   i=6: max(1, 5+1=6) = 6 (이어감), max=6 ✓
   i=7: max(-5, 6-5=1) = 1 (이어감), max=6
   i=8: max(4, 1+4=5) = 5 (이어감), max=6

   결과: [4, -1, 2, 1] = 6

9. 왜 작동하는가?
   - 모든 부분배열은 어딘가에서 끝남
   - 각 위치에서 "여기를 끝으로 하는 최댓값" 추적
   - 이전 합이 음수면 버리는 게 이득 (Greedy한 선택)
   - 이전 합이 양수면 현재 값이 음수여도 계속 (예: 4 + (-1) = 3)

10. 시간 복잡도: O(n) - 배열을 한 번만 순회
11. 공간 복잡도: O(1) - 변수 2개만 사용
"""