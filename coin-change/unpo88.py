class Solution:
    def coinChange(self, coins: list[int], amount: int) -> int:
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0

        for coin in coins:
            for x in range(coin, amount + 1):
                dp[x] = min(dp[x], dp[x - coin] + 1)

        return dp[amount] if dp[amount] != float('inf') else -1

"""
================================================================================
풀이 과정
================================================================================

[1차 시도] 완전 탐색으로 접근하면?
────────────────────────────────────────────────────────────────────────────────
1. 모든 동전 조합을 시도해보면 어떨까?
2. coins = [1, 2, 5], amount = 11
   - 5 + 5 + 1 = 11 (3개)
   - 5 + 2 + 2 + 2 = 11 (4개)
   - 1 + 1 + ... (11개)
   ... 너무 많은 경우의 수!

3. 문제: 시간복잡도가 너무 높음 (지수 시간)
4. 더 효율적인 방법이 필요함 → DP로 접근하자!

────────────────────────────────────────────────────────────────────────────────
[2차 시도] DP 초기화와 점화식
────────────────────────────────────────────────────────────────────────────────
5. dp[i] = i원을 만드는데 필요한 최소 동전 개수
6. 초기화:
   - dp[0] = 0 (0원 만들기 = 동전 0개)
   - dp[1~amount] = 아직 계산 안 됨

        dp = [float('inf')] * (amount + 1)
        dp[0] = 0

7. 점화식:
    - 각 동전 coin에 대해
    - dp[x] = min(dp[x], dp[x - coin] + 1)
    - 의미: "x원 = (x-coin)원 + coin 1개"

8. Eample) coins = [1, 2, 5], amount = 11

    초기: dp = [0, inf, inf, inf, ..., inf]

    동전 1 처리:
    dp[1] = min(inf, dp[0]+1) = 1
    dp[2] = min(inf, dp[1]+1) = 2
    dp[3] = min(inf, dp[2]+1) = 3
    ...

    동전 2 처리:
    dp[2] = min(2, dp[0]+1) = 1  # 2원 동전 1개!
    dp[3] = min(3, dp[1]+1) = 2  # 2+1
    dp[4] = min(4, dp[2]+1) = 2  # 2+2
    ...

    동전 5 처리:
    dp[5] = min(5, dp[0]+1) = 1  # 5원 동전 1개!
    dp[6] = min(6, dp[1]+1) = 2  # 5+1
    dp[10] = min(10, dp[5]+1) = 2  # 5+5
    dp[11] = min(11, dp[6]+1) = 3  # 5+5+1


[최종 구현] Bottom-Up DP
────────────────────────────────────────────────────────────────────────────────
12. 모든 동전에 대해 반복
13. 각 동전으로 만들 수 있는 모든 금액 업데이트
14. 불가능하면 -1 반환 (dp[amount]가 여전히 무한대)

        for coin in coins:
            for x in range(coin, amount + 1):
                dp[x] = min(dp[x], dp[x - coin] + 1)

        return dp[amount] if dp[amount] != float('inf') else -1

15. 시간복잡도: O(amount × coins) - 효율적!
16. 공간복잡도: O(amount) - dp 배열
"""
